# -2020
2020，从0开始
学习数据结构和设计模式部分

1、学习了工厂模式，观察者模式和模板模式；



【学习总结】《大话数据结构》- 第1章-数据结构绪论
【学习总结】《大话数据结构》- 总
启示：
数据结构：相互之间存在一种或多种特定关系的数据元素的集合。
目录
1.1 开场白
1.2 你数据结构怎么学的？
1.3 数据结构起源
1.4 基本概念和术语
1.5 逻辑结构和物理结构
1.6 抽象数据类型
1.7 总结回顾
1.8 结尾语
========================================

1.1 开场白
一些可以略过的场面话...
========================================

1.2 你数据结构怎么学的？
举了一个在实时排队系统中使用队列结构而不是数组或者数据库的栗子
说明数据结构的重要性
========================================

1.3 数据结构起源
数据结构发展历程
1986年：作为一门独立课程在CS学位课程中出现
70年代初，结构程序设计成为程序设计方法学的主要内容，数据结构在程序设计中占据重要地位
========================================

1.4 基本概念和术语
程序设计=数据结构+算法
数据：
描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别、并输入给计算机处理的符号集合。
（包括数值、声音、图像、视频等各种符号）
- ### 符合两个条件：
- 可以输入到计算机中
- 能被计算机程序处理

数据元素：
组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
（人类的数据元素：人）
（禽类的数据元素：鸡鸭鹅）

数据项：
一个数据元素可以由若干数据项组成。数据项是数据不可分割的最小单位。
（人元素：眼耳鼻嘴手，或者姓名、年龄、性别、出生地、联系电话等）

数据对象(简称为数据)：
性质相同的数据元素的集合，是数据的子集。
（性质相同--指的是数据元素具有相同数量和类型的数据项）
（比如人--都有姓名、生日、性别等相同的数据项）

数据结构：
结构：不同数据元素之间不是独立的，而是存在特定的关系，这些关系称为结构。
数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
========================================

1.5 逻辑结构和物理结构
按照视点不同，将数据结构分为逻辑结构和物理结构。
逻辑结构：
指数据对象中数据元素之间的相互关系。分为四种：

- ### 1-集合结构：数据元素除了同属于一个集合外，相互之间没有其他关系。
（各个元素是平等的）
- ### 2-线性结构：数据元素之间是一对一的关系。
- ### 3-树形结构：数据元素之间存在一对多的层次关系。
- ### 4-图形结构：数据元素之间是多对多的关系。
- ### 可见：逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。

物理结构（存储结构）：
指数据的逻辑结构在计算机中的存储形式。分为两种：
（数据的存储结构应正确反映数据元素之间的逻辑关系）

1-顺序存储结构<排队>
把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。


2-链式存储结构<叫号不排队>
把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。存储关系不反映其逻辑关系。


逻辑结构是面向问题的，而物理结构是面向计算机的，其基本目标就是将数据结构及其逻辑关系存储到计算机的内存中。
========================================

1.6 抽象数据类型
数据类型：
指一组性质相同的值的集合及定义在此集合上的一些操作的总称。


抽象数据类型(Abstract Data Type, ADT)
指一个数学模型及定义在该模型上的一组操作。
描述抽象数据类型的标准格式：


========================================

1.7 总结回顾
分类：


========================================

1.8 结尾语
END 

2.1 开场白
一些可以略过的场面话...
========================================

2.2 数据结构与算法关系
举例独角戏《梁山伯》、《罗密欧》类比数据结构和算法的亲密关系
本课程以数据结构为主，算法为辅
========================================

2.3 两种算法的比较
举例求1+2+3+...+100的两种方法

1-for循环：sum = sum+i
2-小高斯公式法：sum = (1+n)*n / 2
重点在于：数值小时差不多，数值很大、巨大时，for循环就显得很慢很重了。。

========================================

2.4 算法定义
算法（Algorithm）这个单词最早出现在波斯数学家阿勒·花刺子密的公元825年《印度数字算术》中
算法：
解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
指令：能被人或计算机等计算装置执行。可以是计算机指令，也可以是语言文字。
需要把指令表示成一定的操作序列。操作序列包括一组操作，每个操作都完成特定的功能。这就是算法了。
不同问题，对应不同算法。相当于不同的病症，对应不同的药方。
========================================

2.5 算法特性
五个特性：输入、输出、有穷性、确定性、可行性。
1-输入输出：
可以有0个或多个输入，至少有一个或多个输出。
输出：可以是打印，或者返回一个或多个值，等。
（没有输出的算法，是没有意义的，相当于做了无用功，所以至少有一个输出，即返回值，或运行后导致了某些改变）

2-有穷性：
定义：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
注：‘有穷’：不是纯数学意义的，而是在实际应用中合理的、可接受的'有边界'
（例子：一个算法，需要运行二十年，这是数学意义的有穷的，但是现实意义不大了）

3-确定性：
定义：算法的每一步骤都具有确定的含义，不会出现二义性。
具体地：一定条件下，只有一条执行路径，相同输入只能有唯一的输出结果，每个步骤都被精确定义而无歧义。
4-可行性：
定义：每一步都必须是可行的，即每一步都能够通过执行有限次数完成。
具体地：可行性意味着算法可以转换为程序上机运行，并得到正确的结果。
========================================

2.6 算法设计的要求
要求：正确性、可读性、健壮性、时间效率高和存储量低、
1-正确性：
定义：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

2-可读性：
定义：算法设计的另一目的是为了便于阅读、理解和交流。
可读性是算法（包括实现它的代码）好坏的很重要的标志。
3-健壮性：
定义：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。
4-时间效率高和存储量低
考虑时间复杂度和空间复杂度的问题
用最少的存储空间，花最少的时间，办成同样的事，就是好的算法。
========================================

2.7 算法效率的度量方法
1-事后统计方法：
主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
这种方法具有很大缺陷，比如需要事先编制程序、时间依赖硬件和软件，测试数据设计困难等
故不予采纳本方法
2-事前分析估算方法
定义：在计算机程序编制前，依据统计方法对算法进行估算。


一个程序的运行时间：(抛开硬件、软件因素)，依赖于算法的好坏和问题的输入规模。输入规模即输入量的多少。
求和的两个方法的对比：


另一个双层for循环的例子：


故：测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。
分析一个算法的运行时间时，要把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。


========================================

2.8 函数的渐近增长
定义：


判断一个算法的效率时，函数中的常数和其他次要项可以忽略，而更应该关注主项（最高阶项）的阶数。
========================================

2.9 算法时间复杂度
1-定义：
在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模n的函数，进而分析 T(n) 随n的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))，表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模n的某个函数。
大O记法：用大写 O() 来体现算法时间复杂度的记法。
随着n的增大，T(n)增长最慢的算法为最优算法。
常见时间复杂度的非官方名称：O(1)-常数阶，O(n)-线性阶，O(n^2)-平方阶
2-推导大O阶方法
攻略：


3-常数阶
口诀'1'：用常数1取代运行时间中的所有加法常数。
注意：不管常数是多少，均记作O(1)
另：分支结构(if结构，switch语句)--无论真假，执行次数恒定，故也是常数阶。
栗子一枚：


4-线性阶
关键：分析循环结构的运行情况
栗子一枚：


5-对数阶
关键：当循环体中有加快循环的语句时
栗子一枚：


6-平方阶
关键：循环的时间复杂度=循环体的复杂度*该循环运行次数（嵌套for时）
例子：



========================================

2.10 常见的时间复杂度
表格总结：


不同时间复杂度的时间耗费排序：
O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n3)<O(2n)<O(n!)<O<(nn)
========================================

2.11 最坏情况与平均情况
时间复杂度的两种常见类型：
平均时间复杂度（最有意义的，是期望的运行时间）
最坏时间复杂度（最重要的，一种保证，运行时间不会再坏了）
一般没有特殊说明的情况下，默认是最坏时间复杂度
========================================

2.12 算法空间复杂度
空间复杂度：
通过计算算法所需的存储空间实现
计算公式：
S(n) = O(f(n)) - 也用大O表示
通常以时间复杂度为重，不用限定词时默认为时间复杂度。
========================================

2.13 总结回顾
算法的定义：解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。
算法的特性：有穷性、确定性、可行性、输入、输出。
算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求。
算法的度量方法：事后统计方法（不科学不准确）和事前分析估算方法。
函数的渐近增长
推导大O的步骤（123）
常见时间复杂度耗时排序
========================================

2.14 结尾语
END
3.1 开场白
一些可以略过的场面话...
由一个例子引入：幼儿园小朋友排队，左右两侧每次都是固定的人，方便清点和避免丢失。
========================================

3.2 线性表的定义
定义：线性表（list）- 零个或多个数据元素的有限序列。
几个关键点：
1-“序列”：第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。
2-“有限”：元素的个数是有限的。
3-再加一点：元素类型相同。

数学语言定义：


线性表的长度：线性表元素的个数n(n≥0)定义为线性表的长度。n=0时，称为空表。
位序：ai是第i个数据元素，称i为数据元素ai在线性表中的位序。
一些线性表的例子：
12星座-有序，有限，是线性表
公司的组织架构，一个boss手下几个人那种：不是线性表，每个元素不只有一个后继。
班级同学之间的友谊：不是线性关系，每个人都可以和多个同学建立友谊
爱情：不是线性关系，否则每个人都有一个爱的人和被爱的人且不是同一个人....
班级点名册：是线性表，按学号排序，有序有限，类型相同，并且作为复杂的线性表，一个数据元素由若干个数据项组成。
书包占位所以要插队：不能，因为排队是线性表，而书包数据类型不同，别人都是人，书包不是人，所以不是线性表，不能插队。
========================================

3.3 线性表的抽象数据类型
第一章讲过“抽象数据类型”，大致包含类型名称、data、operation等
线性表的操作<对比幼儿园小朋友排队>：
线性表的创建和初始化过程：老师给小朋友们排一个可以长期使用的队
线性表重置为空表的操作：排好后发现高矮不一，于是解散重排
根据位序得到数据元素：问到队伍里第5个小朋友是谁，老师很快能说出来这个小朋友的名字、家长等。
查找某个元素：找一下麦兜是否是班里的小朋友，老师会告诉你，不是的
插入数据和删除数据：有新来的小朋友，或者有小朋友生病请假时
线性表的抽象数据类型定义：



涉及更复杂的操作时，可以用以上的基本操作的组合来实现。
例如求两个线性表集合A和B的并集：可以把存在B中但不存在A中的数据元素插入到A中


========================================

3.4 线性表的顺序存储结构
这部分了解一下线性表的两种物理结构之一----顺序存储结构
1-定义：线性表的顺序存储结构，指用一段地址连续的存储单元依次存储线性表的数据元素。


2-顺序存储方式：
依次，每个数据元素类型相同，可以用c语言的一维数组来实现顺序存储结构。
代码实现：


描述顺序存储结构需要三个属性：
1-存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置
2-线性表的最大存储容量：数组长度MaxSize
3-线性表的当前长度：length
3-数据长度和线性表长度的区别
数组长度：是存放线性表的存储空间的长度，存储分配后这个量是一般不变的。
线性表长度：线性表中数据元素的个数，随着插入删除操作而变化。
注意：线性表的长度总是小于等于数组的长度。
4-地址的计算方法
地址：存储器中的每个存储单元都有自己的编号，这个编号称为地址。（内存地址）
计数：线性表从1开始，而c语言中的数组从0开始


LOC：获得存储位置的函数（假设每个数据元素占c个存储单元）




通过上述公式，可以随时算出线性表中任意位置的地址，且都是相同时间。
即时间复杂度：O(1) -- 每个位置存、取数据，都是相等的时间，也就是一个常数。
通常把具有这一特点的存储结构称为<随机存取结构>
========================================

3.5 顺序存储结构的插入与删除
0-注意点
0.1-线性表的第 i 个数是从1开始计数，而数组下标[]是从0开始计数
0.2-时刻保持清醒，分清到底是 i 还是 i-1
0.3-L->data和L.data：（点出现在取数中，箭头出现在插入删除中）
L->data中L是结构体指针；L.data中L是结构体变量；一说：点适合顺序结构，箭头适合链式结构。
1-获得元素操作 - GetElem



2-插入操作
图示：


插入算法的思路：
1-如果插入位置不合理，抛出异常；
2-如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
3-从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
（注：从最后一个元素开始，依次往后挪一位，否则最后一个不动，前面没位置的）
4-将要插入元素填入位置i处；
5-表长加1.
代码实现：

（注：if中排除i>length+1是符合的，因为跟表不挨着，插入和表无关啦，而if中不包含临界点i=length+1的情况，因为if进行的是判断错误和移动数据，当i=length+1时，直接运行插入数据赋值即可，即if判断后的那条语句）

3-删除操作
图示：


删除算法的思路：
1-如果删除位置不合理，抛出异常；
2-取出删除元素；
3-从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
（注：从删除元素的位置开始，依次往前挪，后面的跟上，就把空位补上了）
4-表长减1.
代码实现：



4-插入、删除的时间复杂度分析：O(n)
最好的情况：在最后一个位置插入或删除：O(1)
最坏的情况：在第一个位置插入或删除：O(n)
平均：(n-1)/2
5-线性表的顺序存储结构---不同操作的时间复杂度对比：
存取操作：O(1)
插入删除：O(n)
综上：顺序存储结构适合元素个数不太变化的，更多是存取数据的应用
6-线性表的顺序存储结构的优缺点：


========================================

3.6 线性表的链式存储结构
1-顺序存储结构的不足的解决方法
顺序存储的最大缺点：插入和删除需要移动大量元素，非常耗费时间。
原因：相邻元素的存储位置也具有邻居关系，它们在内存中的位置是挨着的，无法快速介入。
思路：不要考虑元素的相邻位置，只让每个元素知道它的下一个元素的地址，可以找到即可
2-线性表链式存储结构的定义
特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以连续，也可以不连续。（顺序存储要求地址连续）
负担：顺序结构中，每个数据元素只需要存数据元素的信息，而链式结构中，还需要存储它的后继元素的存储地址。




头指针：链表中第一个结点的存储位置叫做头指针。整个链表的存取从头指针开始。
最后一个结点的指针：后继不存在，应为空，通常用NULL或“^”表示是


头结点：为方便对链表进行操作，在单链表的第一个结点前附设一个结点，称为头结点。
头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储第一个结点的指针。


3-头结点与头指针的异同


注：头指针-->（头结点）-->开始结点（第一个结点）
一个单链表可以由其头指针唯一确定，一般用其头指针来命名单链表
不论链表是否为空，头指针总是非空
单链表的头指针指向头结点。
头结点的指针域存储指向第一结点的指针（即第一个元素结点的存储位置）
若线性表为空表，则头结点的指针域为空。
参考：数据结构中的开始结点、头指针、头结点
4-线性表链式存储结构的代码描述
空链表图示：线性表为空表，则头结点的指针域为‘空’


更方便的单链表图示：


带有头结点的单链表图示：


新的空链表图示：


单链表的代码：（用结构指针来描述）


结点：由存放数据元素的数据域，和存放后继结点地址的指针域组成。
设p是指向线性表第i个元素的指针，则
p->data：其值是一个数据元素，表示结点ai的数据域
p->next：其值是一个指针，表示结点ai的指针域，指向第i+1个元素
p->data=ai
p->next->data=ai+1
p和(p->next)都是指针，同等看待


========================================

3.7 单链表的读取
相比顺序存储结构的非常容易的读取，要得到单链表的第i个元素，必须从头开始找
算法思路：
1-声明一个结点p指向链表第一个结点，初始化j从1开始；
2-当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
3-若到链表末尾p为空，则说明第i个元素不存在；
4-否则查找成功，返回结点p的数据。
代码实现：
（ps: 链表L的头结点是L->next？？）



时间复杂度：O(n)
最好的情况：i=1时不需要遍历
最坏的情况：i=n时遍历n-1次
PS：事先不知道要循环的次数，因此不方便用for循环。while循环也是循环!!!~~
核心思想：“工作指针后移”
========================================

3.8 单链表的插入与删除
1-单链表的插入
将s结点插入到结点p和p->next之间


操作代码：s->next=p->next; p->next=s;
-- 把p的后继结点改为s的后继结点，再把结点s变成p的后继结点<顺序不可换否则会覆盖p->next的值>



单链表的表头和表尾的操作：


单链表第i个数据插入结点的算法思路：
1-声明一结点p指向链表第一个结点，初始化j从1开始；
2-当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
3-若到链表末尾p为空，则说明第i个元素不存在；
4-否则查找成功，在系统中生成一个空节点s；
5-将数据元素e赋值给s->data；
6-单链表的插入标准语句：s->next=p->next; p->next=s;
7-返回成功。
代码实现：


2-单链表的删除
将结点q删除，其中q为存储元素ai的结点。
其实就是将它的前继结点的指针绕过，指向它的后继结点即可。


操作代码：q=p->next; p->next=q->next; (p->next=p->next->next，用q来取代p->next)


单链表第i个数据删除结点的算法思路：
1-声明一结点p指向链表第一个结点，初始化j从1开始；
2-当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3-若到链表末尾p为空，则说明第i个元素不存在；
4-否则查找成功，将欲删除的结点p->next赋值给q；
5-单链表的删除标准语句：p->next=q->next；
6-将q结点中的数据赋值给e，作为返回；
7-释放q结点；
8-返回成功。
代码实现：


3-时间复杂度分析
单链表的插入和删除：首先是遍历查找第i个元素，其次是插入和删除操作
故时间复杂度是O(n)
当插入删除一个元素时，与顺序结构比，没有太大优势
但是当从第i个元素的位置插入10个元素时：
顺序结构：每次插入都需要移动元素，每次都是O(n)
单链表：只需要在第一次时，找到第i个位置的指针，此时为O(n)，后面每次都是O(1)
综上，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。
========================================

3.9 单链表的整表创建
对比顺序结构和单链表的创建：
顺序存储结构的创建：相当于一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。
单链表的创建：动态结构，对于每个链表，它所占空间的大小和位置不需要预先分配划定，可根据需求即时生成。
故：创建单链表：一个动态生成链表的过程，即从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表。
单链表整表创建的算法思路：
1-声明一结点p和计数器变量i；
2-初始化一空链表L；
3-让L的头结点的指针指向NULL，即建立一个带头结点的单链表；
4-循环：
生成一新结点赋值给p；
随机生成一数字赋值给p的数据域p->data；
将p插入到头结点与前一新结点之间。
头插法：
头插法思路：始终让新结点在第一的位置
头插法--代码实现：



注：先把 ( * L ) -> next 赋值给 p 结点的指针域，再把 p 结点赋值给头结点的指针域
否则会覆盖 ( * L ) -> next
头插法--图示：


尾插法：
尾插法思路：新结点插在终端结点的后面
尾插法--代码实现：
（注：头插法先定义一个头结点，而尾插法不需要头结点）



尾插法--图示：
注：L是指整个单链表，r是指向尾结点的变量，r随着循环不断地变化结点，而L随着循环增长为一个多结点的链表



循环结束后，r->next=NULL--让这个链表的指针域置空。
========================================

3.10 单链表的整表删除
单链表整表删除的算法思路：
1-声明一结点p和q；
2-将第一个结点赋值给p；
3-循环；
将下一结点赋值给q；
释放p；
将q赋值给p
代码实现：


========================================

3.11 单链表结构与顺序存储结构优缺点
简单对比单链表结构和顺序存储结构;


对比得出的一些经验性的结论：
1-若线性表多查找，少插删，宜采用顺序存储结构；若多查删，宜采用单链表结构
举例：游戏开发中，用户注册信息时，除了注册时插入，其他时候多读取，用顺序；而玩家的装备随时增删，用单链表。
2-若线性表的元素个数变化大或不确定时，宜采用单链表；若确定或事先明确个数，用顺序存储效率更高。
3-总结：各有优缺点，不能简单说哪个好哪个不好，需要根据实际情况综合分析哪种更合适。
========================================

3.12 静态链表
引入：
1-出现问题：c有指针，而有些面向对象语言如java、c#等启用了对象引用机制，间接实现了指针的作用；而有些语言如basic等没有指针，如何实现链表结构呢？
2-解决思路：用数组代替指针，来描述单链表
定义：用数组描述的链表叫做静态链表，或曰“游标实现法”。
数组的元素都是由两个数据域组成的，data（数据）和cur（游标）
即数组的每个下标都对应一个data和一个cur
数据域data：用来存放数据元素，也就是我们要处理的数据。
游标cur：相当于单链表中的next指针，存放该元素的后继在数组中的下标。
注：此处的游标cur不是数组的索引，而是数组索引之外的又一个值



备用链表：通常把未被使用的数组元素称为备用链表。（即数组的后面还没填充数据的空闲空间）
对于数组特殊元素的设置：


上图示此时相当于初始化的数组状态。对应的代码实现：


将数据存入后的状态：

（注，左上角笔误：空闲空间，不是空间空间。。还有图中标记的所谓“头结点”存疑，可以说是开始结点）

1-静态链表的插入操作
动态链表中：结点的申请和释放分别借用函数malloc()和free()来实现
静态链表中：操作的是数组，需要自己实现这两个函数，以便进行插删操作
malloc()函数的静态链表代码实现：（配合上图食用效果更佳）


静态链表插入操作的代码实现


静态链表插入操作的图示：（在乙和丁之间插入丙，只需改变乙和丙的cur即可）


2-静态链表的删除操作
free()函数的静态链表代码实现：


静态链表删除操作的代码实现：



静态链表删除操作的图示：（）


3-静态链表优缺点


========================================

3.13 循环链表
循环链表（circular linked list）的定义：
将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成了一个环
这种头尾相接的单链表称为单循环链表，简称循环链表
优势：
解决了一个问题：即如何从当中一个结点出发，访问到链表的全部结点。
带有头结点的循环链表图示-空链表和非空链表



循环链表和单链表的差异：循环的判断条件
单链表：判断p->next是否为空
循环链表：判断p->next不等于头结点，则循环未结束
尾指针rear
引入： 有头结点时，访问第一个结点用 O(1)，但访问最后一个结点用O(n)
有了尾指针以后，访问第一个结点和最后一个结点的时间均为O(1)了
尾指针：rear
头指针：rear->next
尾指针图示：


示例：将两个循环链表合并成一个表时：
图示：



代码实现：



========================================

3.14 双向链表
双向链表（double linked list）的定义：
在单链表的每个结点中，再设置一个指向其前驱结点的指针域
即在双向链表中的结点都有两个指针域，一个指向直接后继，一个指向直接前驱
代码实现：


带有头结点的双向链表的图示：空链表和非空链表



双向链表的前驱的后继：它自己
p->next>prior = p = p->prior->next
双向链表的插入操作：
注意顺序：先s的前驱和后继，再后结点的前驱，最后前结点的后继



双向链表的删除操作：




好处和弊端分析
弊端：在插入删除时，需要更改两个指针变量，并且占用更多空间
好处：良好的对称性，有效提高算法的时间性能
综上：用空间换时间
========================================

3.15 总结回顾


========================================

3.16 结尾语
END

