# -2020
2020，从0开始
学习数据结构和设计模式部分

1、学习了工厂模式，观察者模式和模板模式；



【学习总结】《大话数据结构》- 第1章-数据结构绪论
【学习总结】《大话数据结构》- 总
启示：
数据结构：相互之间存在一种或多种特定关系的数据元素的集合。
目录
1.1 开场白
1.2 你数据结构怎么学的？
1.3 数据结构起源
1.4 基本概念和术语
1.5 逻辑结构和物理结构
1.6 抽象数据类型
1.7 总结回顾
1.8 结尾语
========================================

1.1 开场白
一些可以略过的场面话...
========================================

1.2 你数据结构怎么学的？
举了一个在实时排队系统中使用队列结构而不是数组或者数据库的栗子
说明数据结构的重要性
========================================

1.3 数据结构起源
数据结构发展历程
1986年：作为一门独立课程在CS学位课程中出现
70年代初，结构程序设计成为程序设计方法学的主要内容，数据结构在程序设计中占据重要地位
========================================

1.4 基本概念和术语
程序设计=数据结构+算法
数据：
描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别、并输入给计算机处理的符号集合。
（包括数值、声音、图像、视频等各种符号）
- ### 符合两个条件：
- 可以输入到计算机中
- 能被计算机程序处理

数据元素：
组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
（人类的数据元素：人）
（禽类的数据元素：鸡鸭鹅）

数据项：
一个数据元素可以由若干数据项组成。数据项是数据不可分割的最小单位。
（人元素：眼耳鼻嘴手，或者姓名、年龄、性别、出生地、联系电话等）

数据对象(简称为数据)：
性质相同的数据元素的集合，是数据的子集。
（性质相同--指的是数据元素具有相同数量和类型的数据项）
（比如人--都有姓名、生日、性别等相同的数据项）

数据结构：
结构：不同数据元素之间不是独立的，而是存在特定的关系，这些关系称为结构。
数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
========================================

1.5 逻辑结构和物理结构
按照视点不同，将数据结构分为逻辑结构和物理结构。
逻辑结构：
指数据对象中数据元素之间的相互关系。分为四种：

- ### 1-集合结构：数据元素除了同属于一个集合外，相互之间没有其他关系。
（各个元素是平等的）
- ### 2-线性结构：数据元素之间是一对一的关系。
- ### 3-树形结构：数据元素之间存在一对多的层次关系。
- ### 4-图形结构：数据元素之间是多对多的关系。
- ### 可见：逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。

物理结构（存储结构）：
指数据的逻辑结构在计算机中的存储形式。分为两种：
（数据的存储结构应正确反映数据元素之间的逻辑关系）

1-顺序存储结构<排队>
把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。


2-链式存储结构<叫号不排队>
把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。存储关系不反映其逻辑关系。


逻辑结构是面向问题的，而物理结构是面向计算机的，其基本目标就是将数据结构及其逻辑关系存储到计算机的内存中。
========================================

1.6 抽象数据类型
数据类型：
指一组性质相同的值的集合及定义在此集合上的一些操作的总称。


抽象数据类型(Abstract Data Type, ADT)
指一个数学模型及定义在该模型上的一组操作。
描述抽象数据类型的标准格式：


========================================

1.7 总结回顾
分类：


========================================

1.8 结尾语
END 

2.1 开场白
一些可以略过的场面话...
========================================

2.2 数据结构与算法关系
举例独角戏《梁山伯》、《罗密欧》类比数据结构和算法的亲密关系
本课程以数据结构为主，算法为辅
========================================

2.3 两种算法的比较
举例求1+2+3+...+100的两种方法

1-for循环：sum = sum+i
2-小高斯公式法：sum = (1+n)*n / 2
重点在于：数值小时差不多，数值很大、巨大时，for循环就显得很慢很重了。。

========================================

2.4 算法定义
算法（Algorithm）这个单词最早出现在波斯数学家阿勒·花刺子密的公元825年《印度数字算术》中
算法：
解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
指令：能被人或计算机等计算装置执行。可以是计算机指令，也可以是语言文字。
需要把指令表示成一定的操作序列。操作序列包括一组操作，每个操作都完成特定的功能。这就是算法了。
不同问题，对应不同算法。相当于不同的病症，对应不同的药方。
========================================

2.5 算法特性
五个特性：输入、输出、有穷性、确定性、可行性。
1-输入输出：
可以有0个或多个输入，至少有一个或多个输出。
输出：可以是打印，或者返回一个或多个值，等。
（没有输出的算法，是没有意义的，相当于做了无用功，所以至少有一个输出，即返回值，或运行后导致了某些改变）

2-有穷性：
定义：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
注：‘有穷’：不是纯数学意义的，而是在实际应用中合理的、可接受的'有边界'
（例子：一个算法，需要运行二十年，这是数学意义的有穷的，但是现实意义不大了）

3-确定性：
定义：算法的每一步骤都具有确定的含义，不会出现二义性。
具体地：一定条件下，只有一条执行路径，相同输入只能有唯一的输出结果，每个步骤都被精确定义而无歧义。
4-可行性：
定义：每一步都必须是可行的，即每一步都能够通过执行有限次数完成。
具体地：可行性意味着算法可以转换为程序上机运行，并得到正确的结果。
========================================

2.6 算法设计的要求
要求：正确性、可读性、健壮性、时间效率高和存储量低、
1-正确性：
定义：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

2-可读性：
定义：算法设计的另一目的是为了便于阅读、理解和交流。
可读性是算法（包括实现它的代码）好坏的很重要的标志。
3-健壮性：
定义：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。
4-时间效率高和存储量低
考虑时间复杂度和空间复杂度的问题
用最少的存储空间，花最少的时间，办成同样的事，就是好的算法。
========================================

2.7 算法效率的度量方法
1-事后统计方法：
主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
这种方法具有很大缺陷，比如需要事先编制程序、时间依赖硬件和软件，测试数据设计困难等
故不予采纳本方法
2-事前分析估算方法
定义：在计算机程序编制前，依据统计方法对算法进行估算。


一个程序的运行时间：(抛开硬件、软件因素)，依赖于算法的好坏和问题的输入规模。输入规模即输入量的多少。
求和的两个方法的对比：


另一个双层for循环的例子：


故：测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。
分析一个算法的运行时间时，要把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。


========================================

2.8 函数的渐近增长
定义：


判断一个算法的效率时，函数中的常数和其他次要项可以忽略，而更应该关注主项（最高阶项）的阶数。
========================================

2.9 算法时间复杂度
1-定义：
在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模n的函数，进而分析 T(n) 随n的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))，表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模n的某个函数。
大O记法：用大写 O() 来体现算法时间复杂度的记法。
随着n的增大，T(n)增长最慢的算法为最优算法。
常见时间复杂度的非官方名称：O(1)-常数阶，O(n)-线性阶，O(n^2)-平方阶
2-推导大O阶方法
攻略：


3-常数阶
口诀'1'：用常数1取代运行时间中的所有加法常数。
注意：不管常数是多少，均记作O(1)
另：分支结构(if结构，switch语句)--无论真假，执行次数恒定，故也是常数阶。
栗子一枚：


4-线性阶
关键：分析循环结构的运行情况
栗子一枚：


5-对数阶
关键：当循环体中有加快循环的语句时
栗子一枚：


6-平方阶
关键：循环的时间复杂度=循环体的复杂度*该循环运行次数（嵌套for时）
例子：



========================================

2.10 常见的时间复杂度
表格总结：


不同时间复杂度的时间耗费排序：
O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n3)<O(2n)<O(n!)<O<(nn)
========================================

2.11 最坏情况与平均情况
时间复杂度的两种常见类型：
平均时间复杂度（最有意义的，是期望的运行时间）
最坏时间复杂度（最重要的，一种保证，运行时间不会再坏了）
一般没有特殊说明的情况下，默认是最坏时间复杂度
========================================

2.12 算法空间复杂度
空间复杂度：
通过计算算法所需的存储空间实现
计算公式：
S(n) = O(f(n)) - 也用大O表示
通常以时间复杂度为重，不用限定词时默认为时间复杂度。
========================================

2.13 总结回顾
算法的定义：解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。
算法的特性：有穷性、确定性、可行性、输入、输出。
算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求。
算法的度量方法：事后统计方法（不科学不准确）和事前分析估算方法。
函数的渐近增长
推导大O的步骤（123）
常见时间复杂度耗时排序
========================================

2.14 结尾语
END
3.1 开场白
一些可以略过的场面话...
由一个例子引入：幼儿园小朋友排队，左右两侧每次都是固定的人，方便清点和避免丢失。
========================================

3.2 线性表的定义
定义：线性表（list）- 零个或多个数据元素的有限序列。
几个关键点：
1-“序列”：第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。
2-“有限”：元素的个数是有限的。
3-再加一点：元素类型相同。

数学语言定义：


线性表的长度：线性表元素的个数n(n≥0)定义为线性表的长度。n=0时，称为空表。
位序：ai是第i个数据元素，称i为数据元素ai在线性表中的位序。
一些线性表的例子：
12星座-有序，有限，是线性表
公司的组织架构，一个boss手下几个人那种：不是线性表，每个元素不只有一个后继。
班级同学之间的友谊：不是线性关系，每个人都可以和多个同学建立友谊
爱情：不是线性关系，否则每个人都有一个爱的人和被爱的人且不是同一个人....
班级点名册：是线性表，按学号排序，有序有限，类型相同，并且作为复杂的线性表，一个数据元素由若干个数据项组成。
书包占位所以要插队：不能，因为排队是线性表，而书包数据类型不同，别人都是人，书包不是人，所以不是线性表，不能插队。
========================================

3.3 线性表的抽象数据类型
第一章讲过“抽象数据类型”，大致包含类型名称、data、operation等
线性表的操作<对比幼儿园小朋友排队>：
线性表的创建和初始化过程：老师给小朋友们排一个可以长期使用的队
线性表重置为空表的操作：排好后发现高矮不一，于是解散重排
根据位序得到数据元素：问到队伍里第5个小朋友是谁，老师很快能说出来这个小朋友的名字、家长等。
查找某个元素：找一下麦兜是否是班里的小朋友，老师会告诉你，不是的
插入数据和删除数据：有新来的小朋友，或者有小朋友生病请假时
线性表的抽象数据类型定义：



涉及更复杂的操作时，可以用以上的基本操作的组合来实现。
例如求两个线性表集合A和B的并集：可以把存在B中但不存在A中的数据元素插入到A中


========================================

3.4 线性表的顺序存储结构
这部分了解一下线性表的两种物理结构之一----顺序存储结构
1-定义：线性表的顺序存储结构，指用一段地址连续的存储单元依次存储线性表的数据元素。


2-顺序存储方式：
依次，每个数据元素类型相同，可以用c语言的一维数组来实现顺序存储结构。
代码实现：


描述顺序存储结构需要三个属性：
1-存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置
2-线性表的最大存储容量：数组长度MaxSize
3-线性表的当前长度：length
3-数据长度和线性表长度的区别
数组长度：是存放线性表的存储空间的长度，存储分配后这个量是一般不变的。
线性表长度：线性表中数据元素的个数，随着插入删除操作而变化。
注意：线性表的长度总是小于等于数组的长度。
4-地址的计算方法
地址：存储器中的每个存储单元都有自己的编号，这个编号称为地址。（内存地址）
计数：线性表从1开始，而c语言中的数组从0开始


LOC：获得存储位置的函数（假设每个数据元素占c个存储单元）




通过上述公式，可以随时算出线性表中任意位置的地址，且都是相同时间。
即时间复杂度：O(1) -- 每个位置存、取数据，都是相等的时间，也就是一个常数。
通常把具有这一特点的存储结构称为<随机存取结构>
========================================

3.5 顺序存储结构的插入与删除
0-注意点
0.1-线性表的第 i 个数是从1开始计数，而数组下标[]是从0开始计数
0.2-时刻保持清醒，分清到底是 i 还是 i-1
0.3-L->data和L.data：（点出现在取数中，箭头出现在插入删除中）
L->data中L是结构体指针；L.data中L是结构体变量；一说：点适合顺序结构，箭头适合链式结构。
1-获得元素操作 - GetElem



2-插入操作
图示：


插入算法的思路：
1-如果插入位置不合理，抛出异常；
2-如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
3-从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
（注：从最后一个元素开始，依次往后挪一位，否则最后一个不动，前面没位置的）
4-将要插入元素填入位置i处；
5-表长加1.
代码实现：

（注：if中排除i>length+1是符合的，因为跟表不挨着，插入和表无关啦，而if中不包含临界点i=length+1的情况，因为if进行的是判断错误和移动数据，当i=length+1时，直接运行插入数据赋值即可，即if判断后的那条语句）

3-删除操作
图示：


删除算法的思路：
1-如果删除位置不合理，抛出异常；
2-取出删除元素；
3-从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
（注：从删除元素的位置开始，依次往前挪，后面的跟上，就把空位补上了）
4-表长减1.
代码实现：



4-插入、删除的时间复杂度分析：O(n)
最好的情况：在最后一个位置插入或删除：O(1)
最坏的情况：在第一个位置插入或删除：O(n)
平均：(n-1)/2
5-线性表的顺序存储结构---不同操作的时间复杂度对比：
存取操作：O(1)
插入删除：O(n)
综上：顺序存储结构适合元素个数不太变化的，更多是存取数据的应用
6-线性表的顺序存储结构的优缺点：


========================================

3.6 线性表的链式存储结构
1-顺序存储结构的不足的解决方法
顺序存储的最大缺点：插入和删除需要移动大量元素，非常耗费时间。
原因：相邻元素的存储位置也具有邻居关系，它们在内存中的位置是挨着的，无法快速介入。
思路：不要考虑元素的相邻位置，只让每个元素知道它的下一个元素的地址，可以找到即可
2-线性表链式存储结构的定义
特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以连续，也可以不连续。（顺序存储要求地址连续）
负担：顺序结构中，每个数据元素只需要存数据元素的信息，而链式结构中，还需要存储它的后继元素的存储地址。




头指针：链表中第一个结点的存储位置叫做头指针。整个链表的存取从头指针开始。
最后一个结点的指针：后继不存在，应为空，通常用NULL或“^”表示是


头结点：为方便对链表进行操作，在单链表的第一个结点前附设一个结点，称为头结点。
头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储第一个结点的指针。


3-头结点与头指针的异同


注：头指针-->（头结点）-->开始结点（第一个结点）
一个单链表可以由其头指针唯一确定，一般用其头指针来命名单链表
不论链表是否为空，头指针总是非空
单链表的头指针指向头结点。
头结点的指针域存储指向第一结点的指针（即第一个元素结点的存储位置）
若线性表为空表，则头结点的指针域为空。
参考：数据结构中的开始结点、头指针、头结点
4-线性表链式存储结构的代码描述
空链表图示：线性表为空表，则头结点的指针域为‘空’


更方便的单链表图示：


带有头结点的单链表图示：


新的空链表图示：


单链表的代码：（用结构指针来描述）


结点：由存放数据元素的数据域，和存放后继结点地址的指针域组成。
设p是指向线性表第i个元素的指针，则
p->data：其值是一个数据元素，表示结点ai的数据域
p->next：其值是一个指针，表示结点ai的指针域，指向第i+1个元素
p->data=ai
p->next->data=ai+1
p和(p->next)都是指针，同等看待


========================================

3.7 单链表的读取
相比顺序存储结构的非常容易的读取，要得到单链表的第i个元素，必须从头开始找
算法思路：
1-声明一个结点p指向链表第一个结点，初始化j从1开始；
2-当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
3-若到链表末尾p为空，则说明第i个元素不存在；
4-否则查找成功，返回结点p的数据。
代码实现：
（ps: 链表L的头结点是L->next？？）



时间复杂度：O(n)
最好的情况：i=1时不需要遍历
最坏的情况：i=n时遍历n-1次
PS：事先不知道要循环的次数，因此不方便用for循环。while循环也是循环!!!~~
核心思想：“工作指针后移”
========================================

3.8 单链表的插入与删除
1-单链表的插入
将s结点插入到结点p和p->next之间


操作代码：s->next=p->next; p->next=s;
-- 把p的后继结点改为s的后继结点，再把结点s变成p的后继结点<顺序不可换否则会覆盖p->next的值>



单链表的表头和表尾的操作：


单链表第i个数据插入结点的算法思路：
1-声明一结点p指向链表第一个结点，初始化j从1开始；
2-当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
3-若到链表末尾p为空，则说明第i个元素不存在；
4-否则查找成功，在系统中生成一个空节点s；
5-将数据元素e赋值给s->data；
6-单链表的插入标准语句：s->next=p->next; p->next=s;
7-返回成功。
代码实现：


2-单链表的删除
将结点q删除，其中q为存储元素ai的结点。
其实就是将它的前继结点的指针绕过，指向它的后继结点即可。


操作代码：q=p->next; p->next=q->next; (p->next=p->next->next，用q来取代p->next)


单链表第i个数据删除结点的算法思路：
1-声明一结点p指向链表第一个结点，初始化j从1开始；
2-当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3-若到链表末尾p为空，则说明第i个元素不存在；
4-否则查找成功，将欲删除的结点p->next赋值给q；
5-单链表的删除标准语句：p->next=q->next；
6-将q结点中的数据赋值给e，作为返回；
7-释放q结点；
8-返回成功。
代码实现：


3-时间复杂度分析
单链表的插入和删除：首先是遍历查找第i个元素，其次是插入和删除操作
故时间复杂度是O(n)
当插入删除一个元素时，与顺序结构比，没有太大优势
但是当从第i个元素的位置插入10个元素时：
顺序结构：每次插入都需要移动元素，每次都是O(n)
单链表：只需要在第一次时，找到第i个位置的指针，此时为O(n)，后面每次都是O(1)
综上，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。
========================================

3.9 单链表的整表创建
对比顺序结构和单链表的创建：
顺序存储结构的创建：相当于一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。
单链表的创建：动态结构，对于每个链表，它所占空间的大小和位置不需要预先分配划定，可根据需求即时生成。
故：创建单链表：一个动态生成链表的过程，即从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表。
单链表整表创建的算法思路：
1-声明一结点p和计数器变量i；
2-初始化一空链表L；
3-让L的头结点的指针指向NULL，即建立一个带头结点的单链表；
4-循环：
生成一新结点赋值给p；
随机生成一数字赋值给p的数据域p->data；
将p插入到头结点与前一新结点之间。
头插法：
头插法思路：始终让新结点在第一的位置
头插法--代码实现：



注：先把 ( * L ) -> next 赋值给 p 结点的指针域，再把 p 结点赋值给头结点的指针域
否则会覆盖 ( * L ) -> next
头插法--图示：


尾插法：
尾插法思路：新结点插在终端结点的后面
尾插法--代码实现：
（注：头插法先定义一个头结点，而尾插法不需要头结点）



尾插法--图示：
注：L是指整个单链表，r是指向尾结点的变量，r随着循环不断地变化结点，而L随着循环增长为一个多结点的链表



循环结束后，r->next=NULL--让这个链表的指针域置空。
========================================

3.10 单链表的整表删除
单链表整表删除的算法思路：
1-声明一结点p和q；
2-将第一个结点赋值给p；
3-循环；
将下一结点赋值给q；
释放p；
将q赋值给p
代码实现：


========================================

3.11 单链表结构与顺序存储结构优缺点
简单对比单链表结构和顺序存储结构;


对比得出的一些经验性的结论：
1-若线性表多查找，少插删，宜采用顺序存储结构；若多查删，宜采用单链表结构
举例：游戏开发中，用户注册信息时，除了注册时插入，其他时候多读取，用顺序；而玩家的装备随时增删，用单链表。
2-若线性表的元素个数变化大或不确定时，宜采用单链表；若确定或事先明确个数，用顺序存储效率更高。
3-总结：各有优缺点，不能简单说哪个好哪个不好，需要根据实际情况综合分析哪种更合适。
========================================

3.12 静态链表
引入：
1-出现问题：c有指针，而有些面向对象语言如java、c#等启用了对象引用机制，间接实现了指针的作用；而有些语言如basic等没有指针，如何实现链表结构呢？
2-解决思路：用数组代替指针，来描述单链表
定义：用数组描述的链表叫做静态链表，或曰“游标实现法”。
数组的元素都是由两个数据域组成的，data（数据）和cur（游标）
即数组的每个下标都对应一个data和一个cur
数据域data：用来存放数据元素，也就是我们要处理的数据。
游标cur：相当于单链表中的next指针，存放该元素的后继在数组中的下标。
注：此处的游标cur不是数组的索引，而是数组索引之外的又一个值



备用链表：通常把未被使用的数组元素称为备用链表。（即数组的后面还没填充数据的空闲空间）
对于数组特殊元素的设置：


上图示此时相当于初始化的数组状态。对应的代码实现：


将数据存入后的状态：

（注，左上角笔误：空闲空间，不是空间空间。。还有图中标记的所谓“头结点”存疑，可以说是开始结点）

1-静态链表的插入操作
动态链表中：结点的申请和释放分别借用函数malloc()和free()来实现
静态链表中：操作的是数组，需要自己实现这两个函数，以便进行插删操作
malloc()函数的静态链表代码实现：（配合上图食用效果更佳）


静态链表插入操作的代码实现


静态链表插入操作的图示：（在乙和丁之间插入丙，只需改变乙和丙的cur即可）


2-静态链表的删除操作
free()函数的静态链表代码实现：


静态链表删除操作的代码实现：



静态链表删除操作的图示：（）


3-静态链表优缺点


========================================

3.13 循环链表
循环链表（circular linked list）的定义：
将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成了一个环
这种头尾相接的单链表称为单循环链表，简称循环链表
优势：
解决了一个问题：即如何从当中一个结点出发，访问到链表的全部结点。
带有头结点的循环链表图示-空链表和非空链表



循环链表和单链表的差异：循环的判断条件
单链表：判断p->next是否为空
循环链表：判断p->next不等于头结点，则循环未结束
尾指针rear
引入： 有头结点时，访问第一个结点用 O(1)，但访问最后一个结点用O(n)
有了尾指针以后，访问第一个结点和最后一个结点的时间均为O(1)了
尾指针：rear
头指针：rear->next
尾指针图示：


示例：将两个循环链表合并成一个表时：
图示：



代码实现：



========================================

3.14 双向链表
双向链表（double linked list）的定义：
在单链表的每个结点中，再设置一个指向其前驱结点的指针域
即在双向链表中的结点都有两个指针域，一个指向直接后继，一个指向直接前驱
代码实现：


带有头结点的双向链表的图示：空链表和非空链表



双向链表的前驱的后继：它自己
p->next>prior = p = p->prior->next
双向链表的插入操作：
注意顺序：先s的前驱和后继，再后结点的前驱，最后前结点的后继



双向链表的删除操作：




好处和弊端分析
弊端：在插入删除时，需要更改两个指针变量，并且占用更多空间
好处：良好的对称性，有效提高算法的时间性能
综上：用空间换时间
========================================

3.15 总结回顾


========================================

3.16 结尾语
END

4.1 开场白
一些可以略过的场面话...
以左轮手枪和弹夹式手枪的区别引入
========================================

4.2 栈的定义
栈的引入：
栈的常见应用：
软件中的撤销（undo）操作，浏览器历史纪录，Android中的最近任务，Activity的启动模式，CPU中栈的实现，Word自动保存，解析计算式，解析xml/json
定义：栈（stack）是限定仅在表尾进行插入和删除操作的线性表
栈首先是一个线性表，栈元素具有线性关系，即前驱后继关系。
栈顶（top）：允许插入和删除的一端称为栈顶
栈底（bottom）：另一端称为栈底
定义所述“表尾插入删除”，表尾指的是栈顶，而不是栈底
特殊的线性表：特殊在于限制了插入删除的位置，始终在栈顶进行，栈底是固定的
空栈：不含任何数据元素的栈称为空栈
LIFO：last in first out，栈又称为后进先出的线性表，简称LIFO结构
栈的插入操作：进栈，也称压栈、入栈
栈的删除操作：出栈，也称弹栈
进栈出栈变化形式
举例来说，三个int型数字元素1,2,3依次进栈，出栈次序有5种
321：123进，321出
123：1进1出，2进2出，3进3出
213：12进，21出，3进3出
132：1进1出，23进，32出
231：12进，2出，3进，31出
求出栈序列个数：卡特兰数公式：C(2n,n)/(n+1)

- ### 其中，卡特兰数前几项为： 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796​

栈的应用之n阶汉诺塔盘问题（Hanoi）
规则：
在游戏中，总共有n个金属盘片的塔叫做n阶汉诺塔


若要完成n阶汉诺塔，则最少要移动2^n -1次
（没搞懂原理，也没搞懂代码，但是先把结论记下来）

========================================

4.3 栈的抽象数据类型
栈作为线性表，理论上线性表的操作特性都具备
针对特殊性，插入和删除改名为push和pop，即压和弹


========================================

4.4 栈的顺序存储结构及实现
1、栈的顺序存储结构
栈的顺序存储也是线性表顺序存储的简化，简称为顺序栈
数组中，用下标为0的一端作为栈底，因为首元素都存在栈底，变化小
栈顶top：若存储栈长度为StackSize，则top必须小于StackSize
空栈：栈中有一个元素时top=0，以示区别，空栈的判定条件设为top=-1
栈的结构定义：


栈的图示：


2、栈的顺序存储结构--进栈操作push
图示：


代码实现：


3、栈的顺序存储结构--出栈操作
代码实现：


时间复杂度：
进栈、出栈不涉及任何循环语句，时间复杂度均为O(1)
========================================

4.5 两栈共享空间
两栈共享空间的关键思路：
两个栈底分别位于数组的始端（下标0）和数组的末端（下标数组长度n-1），增加元素即从两端点向中间延伸
两栈共享空间的前提：
针对两个具有相同数据类型的栈
两栈共享空间的图示：


栈满：
一般情况：两个栈见面之时，即两个指针相差1，top1+1==top2时
极端情况：2空时，top1=n-1，则1满；1空，top2=0，则2满
两栈共享空间的结构代码：


两栈共享空间的push方法代码实现：
除了要插入元素值参数，还需要一个判断是栈1还是2的栈号参数stackNumber



两栈共享空间的pop方法代码实现：
参数仅为判断栈1或2的参数stackNumber


========================================

4.6 栈的链式存储结构及实现
栈的链式存储结构
栈的链式存储结构，简称链栈
栈顶放在单链表的头部，且不需要头结点
空栈：链表原定义为头指针指向空，故链栈的空是top=NULL
图示：


链栈的结构代码：


链栈的操作大部分与单链表类似，只是插入、删除特殊
栈的链式存储结构--进栈操作
图示：


代码实现：



栈的链式存储结构--删除操作
图示：


代码实现：


时间复杂度：
链栈的push和pop均不涉及循环操作，时间复杂度为O(1)
========================================

4.7 栈的作用
类比明明可以靠脚走到世界上任何地方，为什么还要乘坐飞机火车呢
栈的引入简化了程序涉及的问题，划分了不同关注层次，使思考范围缩小，更加聚焦于问题核心
（比如像数组之类的，要分散精力去考虑数组的下标增减等细节问题。。）
现在许多高级语言如java，c#等，都有对栈结构的封装，不用关心实现细节，直接使用Stack的push和pop方法，非常方便
========================================

4.8 栈的应用--递归
引入：站在相对的两面镜子中间，A中有B，B中有A，会产生无数个“像中像”

斐波那契数列（Fibonacci）
但是我不明白为什么兔子问题和斐波那契数列能扯上关系。。。
公式：


递归代码实现：用递归方式，调用自己


图示：


递归定义
把一个直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称为递归函数。
每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。
迭代和递归的区别：
迭代使用循环结构，递归使用选择结构
递归使程序的结构更清晰、更简洁
递归调用会建立函数的副本，会耗费大量的时间和内存
递归与栈结构：
递归过程退回的顺序是它前进顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前进过程中存储起来的某些数据。
这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，这显然很符合栈这样的数据结构。
========================================

4.9 栈的应用--四则运算表达式求值
后缀（逆波兰）表示法定义
一种不需要括号的后缀表达法，也称为逆波兰（Reverse Polish Notation, RPN）
后缀： 所有的符号都是要在运算数字的后面出现的。
没了括号，机器可以更好地执行。
中缀表达式
定义：常用的标准四则运算表达式，所有的运算符号都在两数字的中间
想要让计算机处理常见的中缀表达式，最重要的有两步：
1、将中缀表达式转化为后缀表达式（栈用来进出运算的符号）
2、将后缀表达式进行运算得出结果（栈用来进出运算的数字）
中缀表达式转后缀表达式（数字全部输出，只有符号进栈出栈）
规则：
从左到右遍历中缀表达式的每个数字和符号
若是数字就输出，即成为后缀表达式的一部分
若是符号，先判断其与栈顶符号的优先级
是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈
若优先级高于栈顶符号，则不用管栈顶，直接压栈
一直到最终输出后缀表达式为止
图示：






- ### 注：右括号不进栈，当匹配到左括号时，直接到左括号的部分出栈

后缀表达式计算结果（只有数字进栈出栈）
规则：
从左到右遍历表达式的每个数字和符号
遇到数字就进栈
遇到符号，就将处于栈顶的两个数字出栈，并运算，且运算结果进栈
一直到最终获得结果
图示：




- ### 注：遇运算符取出两数计算，然后需要结果再次进栈，最终结果会出现在栈里

示例：
中缀表达式：9 + ( 3 - 1 ) * 3 +10 / 2
后缀表达式：9 3 1 - 3 * + 10 2 / +
========================================

4.10 队列的定义
队列的引入：
常见应用：电脑卡壳时，过一会儿又自顾自地按顺序把之前的操作执行一遍；客服排队；键盘输入到显示器输出等，都是队列
定义：队列（queue）-- 只允许在一端进行插入操作，而在另一端进行删除操作的线性表
允许插入的一端称为队尾，允许删除的一端称为队头
（先进先出，因此头作为先进的，会先出，因此删除端是队头）
FIFO：first in first out，先进先出的线性表
图示：设q = (a1, a2, ... , an)
则a1是队头元素，an是队尾元素


========================================

4.11 队列的抽象数据类型
队列同样是线性表，也有类似线性表的各种操作
不同在于：插入只能在队尾，删除只能在队头


========================================

4.12 循环队列
注：栈和队列作为特殊的线性表，同样都具有顺序存储和链式存储两种存储方式。
队列顺序存储的不足
当队头固定设为数组下标为0的位置时：入队O(1)，但出队O(n)



当不限制队头必须在数组下标为0的位置时，可以提高一些性能


引入两个指针：front指向队头，rear指向队尾的下一个位置
当空队列：front=rear


仍存在问题：假溢出


循环队列定义
定义：队列的头尾相接的顺序存储结构称为循环队列。
重新定义队列的空和满
QueueSize：队列的最大尺寸
队列空： front == rear
队列满： front == (rear + 1) % QueueSize
(修改队列满的条件，保留一个元素空间)


计算队列长度的公式：(rear - front + QueueSize) % QueueSize
循环队列的代码实现
结构代码：


初始化代码：


求队列长度代码：



入队列操作代码：


出队列操作代码：


循环队列的相关条件和公式：
1.队空条件：rear==front
2.队满条件：(rear+1) %QueueSIze==front，其中QueueSize为循环队列的最大长度
3.计算队列长度：(rear-front+QueueSize)%QueueSize
4.入队：rear = (rear+1)%QueueSize
5.出队：front = (front+1)%QueueSize
========================================

4.13 队列的链式存储结构及实现
定义：
队列的链式存储结构，其实就是线性表的单链表，但只能尾进头出，简称链队列。
图示：
队头指针指向链队列的头结点，队尾指针指向终端结点


空队列：front和rear都指向头结点


链队列的结构代码：


队列的链式存储结构--入队
入队，即在链表尾部插入结点
图示：


代码实现：


队列的链式存储结构--出队
出队，即头结点的后继结点出队，将头结点的后继改为它后面的结点
若链表除头结点外，只剩一个元素，则需将rear指向头结点
图示：


代码实现：



时间空间复杂度分析 -- 循环队列和链队列对比
时间上：都是O(1)
空间上：
循环队列：事先申请好空间，使用期间不释放
链队列：每次申请和释放结点也会存在一些时间开销
循环队列：固定长度，故存在存储元素个数和空间浪费的问题
链队列：需要指针域，产生一些空间上的开销，在空间上更灵活
========================================

4.14 总结回顾


========================================

4.15 结尾语
END
5.1 开场白
一些可以略过的场面话...
回文诗等引入字符串
========================================

5.2 串的定义
串（string）：由零个或多个字符组成的有限序列，又名叫字符串。


相关概念：
空格串：只包含空格的串。
注意：与空串区别，空格串是有内容有长度的，而且可以不止一个空格
子串：串中任意个数的连续字符组成的子序列，称为该串的子串。
主串：相应地，包含子串的串，称为主串。
子串在主串中的位置：子串的第一个字符在主串中的序号。
========================================

5.3 串的比较
串的比较：通过组成串的字符之间的编码来进行的
而字符的编码：指的是字符在对应字符集中的序号
ASCII 和 Unicode
ASCII码：用8为二进制数表示一个字符，总共可以表示256个字符
Unicode码：用16位二进制数表示一个字符，总共有216个字符，约65万多个字符
（PS：两个字节应该是65000吧，怎么65万了？？？）
为了和ASCII码兼容，Unicode码的前256个字符与ASCII码完全相同。
串相等：长度相等，各个对应位置的字符相等。


串的大小判断：


综上，即从第一个开始，分别遍历两串，当某i项不同时，可以分辨大小
========================================

5.4 串的抽象数据类型
串与线性表的比较：
线性表：更关注单个元素的操作，如查找一个元素，插入或删除一个元素
串：更多是查找子串位置、得到指定位置子串、替换子串等操作




举例一个Index操作的实现代码



========================================

5.5 串的存储结构
串的存储结构与线性表类似，分为两类：顺序和链式
串的顺序存储结构
定义：用一组地址连续的存储单元来存储串中的字符序列。
按照预定义大小，为每个定义的串分配一个固定长度的存储区，一般用定长数组来定义。
一般可以将实际的串长值保存在数组的0下标位置，或者在数组的最后一个下标位置
但有的语言规定在串值后面加一个不计入串长度的结束标记符号“\0”来表示串值的终结（但占用一个空间）


由于过于不便，串的顺序存储操作有一些变化：串值的存储空间可在程序执行过程中动态分配而得
比如堆：可由c语言动态分配函数malloc()和free()来管理
串的链式存储结构
若一个结点存放一个字符，会存在很大的空间浪费
故串的链式可以一个结点放多个字符，最后一个结点若不满，可用#或其他非串值字符补全


这里：一个结点存多少个字符才合适就变得很重要，会直接影响串处理的效率
弊端：窜的链式除了连接两串操作方便，总的来说比如顺序存储灵活，性能也不如。
========================================

5.6 朴素的模式匹配算法
模式匹配的定义：
子串（又称模式串）的定位操作通常称做串的模式匹配，是串中最重要的操作之一。
（比如：找一个单词在一篇文章中的定位问题，一篇文章相当于一个大字符串）

朴素的匹配方法（BRUTE FORCE算法，BF算法）：
对主串的每个字符作为子串开头，与要匹配的字符串进行匹配
对主串做大循环，每个字符开头做要匹配子串的长度的小循环，直到匹配成功或全部遍历完成为止
图示：




代码实现：
（注：不考虑串的其他操作的代码，上一个Index代码中有多个其他操作）



时间复杂度分析：
n：主串长度，m：要匹配子串长度
最好情况：O(1) -- 第一次比较就找到
（没有循环，比较次数是子串长度值，是个常数）
平均情况：O(n+m)
根据等概率原则，平均是(n+m)/2次查找。
（严格讲，书中所举的例子，abcdegoogle匹配google，不是m+n，是(m-n)+n，不知道怎么就弄成m+n了。。）
最坏的情况： O(m×n) （注：(n-m+1)×m）
每遍比较都在最后出现不等，即每遍最多比较m次，最多比较n-m+1遍，总的比较次数最多为m(n-m+1)
<存疑，只有部分有m+n这个说法> 注：虽然，朴素的模式匹配，时间复杂度比较大，但是实际中，一般情况（除非模式串和主串之间存在很多的部分匹配的时候，因为此时每遍需要比较的次数很多，相乘不能近似），真正的执行时间是近似于 O(n+m) 的
========================================

5.7 KMP模式匹配算法
引入：
KMP算法：由三位前辈发表的一个模式匹配算法，可以大大避免重复遍历的情况，称之为克努特-莫里斯-普拉特算法，检查KMP算法。
KMP算法原理
主串S与模式串T有部分相同子串时，可以简化朴素匹配算法中的循环流程
例子1：两串只有一部分相等时，S="abcdefgab", T="abcdex"





例子2：两串有不止一部分相等时，S="abcabcabc", T="abcabx"




next数组
定义：



注：
每次只先判断是否符合中间，并且只看1到j-1的串，并且只看前缀最长能和后缀重复的个数
前后缀若有n个字符相等，k就是n+1
例1：T="abcdex"



例2：T="abcabx"



例3：T="ababaaaba"



例4：T="aaaaaaaab"




KMP模式匹配算法的代码实现
next数组


KMP算法



KMP算法的时间复杂度：O(m+n)
get_next的时间复杂度：O(m)
while循环的时间复杂度：O(n)
KMP算法的改进


代码实现：



nextval数组值推导
注：
根据第j个的next值找它的next值x对应的第x个字符，并判断第j个和第x个字符是否相等
若不相等，保持val值等于next值；若相等，val值等于第x个值的val值


例1：T="ababaaaba"




例2：T="aaaaaaaab"



========================================

5.8 总结回顾
串定义
KMP算法
next数组和nextval数组常见考点
========================================

5.9 结尾语
回文诗千古力作“璇玑图”666
